using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace GSCode.Data.Helpers;

/// <summary>
/// Shared utility for formatting function documentation in a consistent way.
/// </summary>
public static class FunctionDocumentationFormatter
{
    /// <summary>
    /// Formats a description with separator if present.
    /// </summary>
    public static string FormatDescription(string? description)
    {
        if (!string.IsNullOrWhiteSpace(description))
        {
            return $"""
                {description}

                ---
                """;
        }
        return string.Empty;
    }

    /// <summary>
    /// Formats a parameter list for display in code blocks (e.g., "param1, [param2], param3").
    /// </summary>
    public static string FormatParameterList<T>(IEnumerable<T> parameters, Func<T, string> getName, Func<T, bool?> getMandatory)
    {
        var paramList = new List<string>();
        foreach (var parameter in parameters)
        {
            string name = getName(parameter);
            bool isMandatory = getMandatory(parameter).HasValue && getMandatory(parameter).Value;
            
            if (isMandatory)
            {
                paramList.Add(name);
            }
            else
            {
                paramList.Add($"[{name}]");
            }
        }

        return string.Join(", ", paramList);
    }

    /// <summary>
    /// Formats the parameters section with "Called on:" and "Parameters:" list.
    /// </summary>
    public static string FormatParametersSection<TParam, TCalledOn>(
        IEnumerable<TParam> parameters,
        TCalledOn? calledOn,
        Func<TParam, string> getName,
        Func<TParam, bool?> getMandatory,
        Func<TParam, string?> getDescription,
        Func<TCalledOn, string> getCalledOnName)
        where TCalledOn : class
    {
        string calledOnString = calledOn is not null ? $"Called on: `<{getCalledOnName(calledOn)}>`\n" : string.Empty;

        var paramList = parameters.ToList();
        if (paramList.Count == 0 && string.IsNullOrEmpty(calledOnString))
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        sb.Append(calledOnString);

        if (paramList.Count > 0)
        {
            sb.AppendLine("Parameters:");
            foreach (var parameter in paramList)
            {
                string name = getName(parameter);
                bool isMandatory = getMandatory(parameter).HasValue && getMandatory(parameter).Value;
                string parameterNameString = isMandatory ? $"<{name}>" : $"[{name}]";
                string desc = getDescription(parameter) ?? string.Empty;

                sb.AppendLine($"* `{parameterNameString}` {desc}");
            }
        }

        sb.AppendLine();
        sb.Append("---");
        return sb.ToString();
    }

    /// <summary>
    /// Gets the display label for a flag.
    /// </summary>
    public static string GetFlagLabel(string flag)
    {
        return flag switch
        {
            "autogenerated" => "_This documentation was generated from Treyarch's API, which may contain errors._",
            "broken" => "**Do not use this function as it is broken.**",
            "deprecated" => "**This function is deprecated and should not be used.**",
            "useless" => "_This function serves no purpose for modders._",
            _ => string.Empty
        };
    }

    /// <summary>
    /// Formats a list of flags into a display string.
    /// </summary>
    public static string FormatFlags(IEnumerable<string> flags)
    {
        var flagLabels = new List<string>();
        foreach (string flag in flags)
        {
            string label = GetFlagLabel(flag);
            if (!string.IsNullOrEmpty(label))
            {
                flagLabels.Add(label);
            }
        }

        return string.Join('\n', flagLabels);
    }
}
