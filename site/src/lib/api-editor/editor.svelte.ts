import type { ScrFunction, ScrLibrary } from '$lib/models/library';
import { ScrLibrarySchema } from '$lib/models/library';
import { getContext, setContext } from 'svelte';
import { FunctionEditor } from './function-editor.svelte';

const STORAGE_KEY = 'gscode-editor-session';

/**
 * Main editor class that manages the entire API library editing session.
 */
export class Editor {
	library = $state<ScrLibrary | null>(null);
	functions = $state<Map<string, FunctionEditor>>(new Map());

	/** The currently selected function for editing */
	selectedFunction = $state<string | null>(null);

	/** Whether a library is currently loaded */
	readonly hasLibrary = $derived(this.library !== null);

	/** Reactive statistics about function verification and validation status */
	readonly stats = $derived.by(() => {
		let autogeneratedCount = 0;
		let invalidCount = 0;
		let verifiedCount = 0;
		let editedCount = 0;
		let badVerificationCount = 0;
		let deletedCount = 0;
		let newCount = 0;

		for (const fn of this.functions.values()) {
			if (fn.deleted) {
				deletedCount++;
				editedCount++;
				continue;
			}
			if (fn.isNew) {
				newCount++;
			}
			if (fn.isUnverified) {
				autogeneratedCount++;
			}
			if (fn.isInvalid) {
				invalidCount++;
				if (fn.isVerified) {
					badVerificationCount++;
				}
			}
			if (fn.isVerified) {
				verifiedCount++;
			}
			if (fn.edited) {
				editedCount++;
			}
		}

		return {
			autogeneratedCount,
			invalidCount,
			verifiedCount,
			editedCount,
			badVerificationCount,
			deletedCount,
			newCount
		};
	});

	private constructor(library?: ScrLibrary) {
		if (library) {
			this.updateLibrary(library);
		}
	}

	/**
	 * Updates the editor with a new library definition.
	 */
	updateLibrary(library: ScrLibrary) {
		this.library = library;
		this.functions = new Map();

		for (const fn of library.api) {
			this.functions.set(fn.name.toLowerCase(), new FunctionEditor(fn));
		}

		// Select the first function by default
		const firstFn = library.api[0];
		this.selectedFunction = firstFn?.name.toLowerCase() ?? null;
	}

	/**
	 * Exports the current state of the library.
	 * If any functions have been edited, increments the revision and updates the revisedOn date.
	 * Deleted functions are excluded from the export.
	 */
	exportLibrary(): ScrLibrary | null {
		if (!this.library) {
			return null;
		}

		const edited = Array.from(this.functions.values()).some((fn) => fn.edited);
		// Filter out deleted functions from export
		const newApi = Array.from(this.functions.values())
			.filter((fn) => !fn.deleted)
			.map((fn) => fn.function);

		let newRevision = this.library.revision;
		let newRevisedOn = this.library.revisedOn;

		if (edited) {
			newRevision++;
			newRevisedOn = new Date();
		}

		return {
			...this.library,
			api: newApi,
			revision: newRevision,
			revisedOn: newRevisedOn
		};
	}

	/**
	 * Creates a new function with default values.
	 */
	createFunction(): FunctionEditor {
		// Generate a unique name
		let baseName = 'new_function';
		let name = baseName;
		let counter = 1;
		while (this.functions.has(name.toLowerCase())) {
			name = `${baseName}_${counter}`;
			counter++;
		}

		const newFn: ScrFunction = {
			name,
			description: null,
			overloads: [
				{
					calledOn: null,
					parameters: [],
					returns: { void: true }
				}
			],
			flags: ['autogenerated'],
			example: null,
			verifiedInRevision: null,
			remarks: null
		};

		const fnEditor = new FunctionEditor(newFn, true);
		this.functions.set(name.toLowerCase(), fnEditor);

		// Trigger reactivity by reassigning the map
		this.functions = new Map(this.functions);

		// Select the new function
		this.selectedFunction = name.toLowerCase();

		return fnEditor;
	}

	/**
	 * Marks a function as deleted (soft-delete).
	 */
	deleteFunction(name: string): boolean {
		const fnEditor = this.functions.get(name.toLowerCase());
		if (!fnEditor) return false;

		fnEditor.markDeleted();

		// If this was the selected function, select another one
		if (this.selectedFunction === name.toLowerCase()) {
			const nonDeletedFunctions = Array.from(this.functions.values()).filter((fn) => !fn.deleted);
			const firstNonDeleted = nonDeletedFunctions[0];
			this.selectedFunction = firstNonDeleted?.function.name.toLowerCase() ?? null;
		}

		return true;
	}

	/**
	 * Restores a soft-deleted function.
	 */
	restoreFunction(name: string): boolean {
		const fnEditor = this.functions.get(name.toLowerCase());
		if (!fnEditor) return false;

		fnEditor.restore();
		return true;
	}

	/**
	 * Creates an Editor instance from a loaded library.
	 */
	static fromLibrary(library: ScrLibrary): Editor {
		return new Editor(library);
	}

	/**
	 * Creates an empty Editor instance with no library loaded.
	 */
	static empty(): Editor {
		return new Editor();
	}

	/**
	 * Selects a function by name for editing.
	 */
	selectFunction(name: string | null) {
		this.selectedFunction = name?.toLowerCase() ?? null;
	}

	/**
	 * Gets the currently selected FunctionEditor.
	 */
	getSelectedFunction(): FunctionEditor | undefined {
		if (!this.selectedFunction) {
			return undefined;
		}
		return this.functions.get(this.selectedFunction);
	}

	/**
	 * Gets the FunctionEditor for a given function name.
	 */
	getFunction(name: string | undefined): FunctionEditor | undefined {
		if (!name) {
			return undefined;
		}
		return this.functions.get(name.toLowerCase());
	}

	/**
	 * Unloads the current library and clears all state.
	 */
	unloadLibrary() {
		this.library = null;
		this.functions = new Map();
		this.selectedFunction = null;
		this.clearStorage();
	}

	// --- LocalStorage persistence ---

	/**
	 * Saves the current editor state to localStorage.
	 */
	saveToStorage() {
		if (!this.library) {
			this.clearStorage();
			return;
		}

		try {
			const state = {
				library: {
					...this.library,
					revisedOn: this.library.revisedOn.toISOString()
				},
				functions: Array.from(this.functions.entries()).map(([key, fnEditor]) => ({
					key,
					function: fnEditor.function,
					isNew: fnEditor.isNew,
					deleted: fnEditor.deleted
				})),
				selectedFunction: this.selectedFunction
			};

			localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
		} catch (err) {
			console.error('Failed to save editor state to localStorage:', err);
		}
	}

	/**
	 * Clears the saved editor state from localStorage.
	 */
	clearStorage() {
		try {
			localStorage.removeItem(STORAGE_KEY);
		} catch (err) {
			console.error('Failed to clear editor state from localStorage:', err);
		}
	}

	/**
	 * Attempts to restore editor state from localStorage.
	 * Returns true if state was restored, false otherwise.
	 */
	restoreFromStorage(): boolean {
		try {
			const stored = localStorage.getItem(STORAGE_KEY);
			if (!stored) return false;

			const state = JSON.parse(stored);
			if (!state.library) return false;

			// Validate and parse the library
			const validatedLibrary = ScrLibrarySchema.parse(state.library);

			this.library = validatedLibrary;
			this.functions = new Map();

			// Restore function editors with their state
			for (const fnState of state.functions) {
				const fnEditor = new FunctionEditor(fnState.function, fnState.isNew);
				if (fnState.deleted) {
					fnEditor.markDeleted();
				}
				this.functions.set(fnState.key, fnEditor);
			}

			this.selectedFunction = state.selectedFunction;
			return true;
		} catch (err) {
			console.error('Failed to restore editor state from localStorage:', err);
			this.clearStorage();
			return false;
		}
	}

	/**
	 * Checks if there's a saved session in localStorage.
	 */
	static hasSavedSession(): boolean {
		try {
			return localStorage.getItem(STORAGE_KEY) !== null;
		} catch {
			return false;
		}
	}
}

const EDITOR_CTX_KEY = Symbol('editor');

export function setEditorContext(editor: Editor) {
	setContext(EDITOR_CTX_KEY, editor);
}

export function getEditorContext(): Editor {
	const editor = getContext<Editor>(EDITOR_CTX_KEY);
	if (!editor) {
		throw new Error('Editor context not found');
	}
	return editor;
}
