import type {
	ScrDataType,
	ScrFunction,
	ScrFunctionOverload,
	ScrFunctionParameter,
	ScrReturnValue
} from '$lib/models/library';
import { validateFunction } from './validation';

/**
 * Wraps an individual function with editor state and validation.
 */
export class FunctionEditor {
	function: ScrFunction = $state() as any;
	private readonly _originalFunction: string;

	/** Whether this function was newly created in this session (not in original library) */
	readonly isNew: boolean;

	/** Whether this function is marked for deletion (soft-delete) */
	deleted = $state(false);

	/** List of validation error messages for this function */
	readonly validationErrors = $derived(validateFunction(this.function));

	/** Whether this function's definition passes validation */
	readonly isValid = $derived(this.validationErrors.length === 0);

	/** Whether this function is verified (has 'verified' flag) */
	readonly isVerified = $derived(this.function?.flags.includes('verified') ?? false);

	/** Whether this function is unverified (does not have 'verified' flag) */
	readonly isUnverified = $derived(!this.isVerified);

	/** Whether this function is invalid (fails validation) */
	readonly isInvalid = $derived(!this.isValid);

	readonly edited = $derived.by(() => {
		if (this.deleted) return true;
		if (!this.function || !this._originalFunction) return false;
		return JSON.stringify(this.function) !== this._originalFunction;
	});

	constructor(fn: ScrFunction, isNew = false) {
		this.function = fn;
		this._originalFunction = JSON.stringify(fn);
		this.isNew = isNew;
	}

	/** Mark this function for deletion */
	markDeleted() {
		this.deleted = true;
	}

	/** Restore this function from deletion */
	restore() {
		this.deleted = false;
	}

	setName(name: string) {
		this.function.name = name;
	}

	setDescription(description: string) {
		this.function.description = description || null;
	}

	setExample(example: string) {
		this.function.example = example || null;
	}

	toggleFlag(flag: string) {
		if (this.function.flags.includes(flag)) {
			this.function.flags = this.function.flags.filter((f) => f !== flag);
		} else {
			let newFlags = [...this.function.flags, flag];
			// Enforce mutual exclusivity for autogenerated and verified
			if (flag === 'verified') {
				newFlags = newFlags.filter((f) => f !== 'autogenerated');
			} else if (flag === 'autogenerated') {
				newFlags = newFlags.filter((f) => f !== 'verified');
			}
			this.function.flags = newFlags;
		}
	}

	// --- Returns editing methods ---

	private ensureReturns(overloadIndex: number): ScrReturnValue {
		const overload = this.function.overloads[overloadIndex];
		overload.returns ??= { void: true };
		return overload.returns;
	}

	setReturnsVoid(overloadIndex: number, isVoid: boolean) {
		const returns = this.ensureReturns(overloadIndex);
		if (isVoid) {
			// Clear type info when setting to void
			returns.void = true;
			returns.type = null;
			returns.name = null;
			returns.description = null;
		} else {
			returns.void = false;
		}
		// Trigger reactivity by reassigning the overloads array
		this.function.overloads = [...this.function.overloads];
	}

	setReturnsType(overloadIndex: number, type: ScrDataType | null) {
		const returns = this.ensureReturns(overloadIndex);
		returns.type = type;
		returns.void = false;
		this.function.overloads = [...this.function.overloads];
	}

	setReturnsName(overloadIndex: number, name: string) {
		const returns = this.ensureReturns(overloadIndex);
		returns.name = name || null;
		this.function.overloads = [...this.function.overloads];
	}

	setReturnsDescription(overloadIndex: number, description: string) {
		const returns = this.ensureReturns(overloadIndex);
		returns.description = description || null;
		this.function.overloads = [...this.function.overloads];
	}

	// --- CalledOn editing methods ---

	private ensureCalledOn(overloadIndex: number): ScrFunctionParameter {
		const overload = this.function.overloads[overloadIndex];
		overload.calledOn ??= { type: null };
		return overload.calledOn;
	}

	setCalledOnEnabled(overloadIndex: number, enabled: boolean) {
		const overload = this.function.overloads[overloadIndex];
		if (enabled) {
			overload.calledOn ??= { type: null };
		} else {
			overload.calledOn = null;
		}
		this.function.overloads = [...this.function.overloads];
	}

	setCalledOnType(overloadIndex: number, type: ScrDataType | null) {
		const calledOn = this.ensureCalledOn(overloadIndex);
		calledOn.type = type;
		this.function.overloads = [...this.function.overloads];
	}

	setCalledOnName(overloadIndex: number, name: string) {
		const calledOn = this.ensureCalledOn(overloadIndex);
		calledOn.name = name || null;
		this.function.overloads = [...this.function.overloads];
	}

	setCalledOnDescription(overloadIndex: number, description: string) {
		const calledOn = this.ensureCalledOn(overloadIndex);
		calledOn.description = description || null;
		this.function.overloads = [...this.function.overloads];
	}

	// --- Parameters editing methods ---

	addParameter(overloadIndex: number) {
		const overload = this.function.overloads[overloadIndex];
		overload.parameters = [
			...overload.parameters,
			{ name: 'new_param', description: null, mandatory: true, type: null }
		];
		this.function.overloads = [...this.function.overloads];
	}

	removeParameter(overloadIndex: number, paramIndex: number) {
		const overload = this.function.overloads[overloadIndex];
		overload.parameters = overload.parameters.filter((_, i) => i !== paramIndex);
		this.function.overloads = [...this.function.overloads];
	}

	setParameterName(overloadIndex: number, paramIndex: number, name: string) {
		const overload = this.function.overloads[overloadIndex];
		overload.parameters[paramIndex].name = name || null;
		this.function.overloads = [...this.function.overloads];
	}

	setParameterDescription(overloadIndex: number, paramIndex: number, description: string) {
		const overload = this.function.overloads[overloadIndex];
		overload.parameters[paramIndex].description = description || null;
		this.function.overloads = [...this.function.overloads];
	}

	setParameterType(overloadIndex: number, paramIndex: number, type: ScrDataType | null) {
		const overload = this.function.overloads[overloadIndex];
		overload.parameters[paramIndex].type = type;
		this.function.overloads = [...this.function.overloads];
	}

	setParameterMandatory(overloadIndex: number, paramIndex: number, mandatory: boolean) {
		const overload = this.function.overloads[overloadIndex];
		overload.parameters[paramIndex].mandatory = mandatory;
		this.function.overloads = [...this.function.overloads];
	}

	setParameterVariadic(overloadIndex: number, paramIndex: number, variadic: boolean) {
		const overload = this.function.overloads[overloadIndex];
		overload.parameters[paramIndex].variadic = variadic;
		this.function.overloads = [...this.function.overloads];
	}

	moveParameter(overloadIndex: number, paramIndex: number, direction: 'up' | 'down') {
		const overload = this.function.overloads[overloadIndex];
		const newIndex = direction === 'up' ? paramIndex - 1 : paramIndex + 1;

		if (newIndex < 0 || newIndex >= overload.parameters.length) return;

		const params = [...overload.parameters];
		[params[paramIndex], params[newIndex]] = [params[newIndex], params[paramIndex]];
		overload.parameters = params;
		this.function.overloads = [...this.function.overloads];
	}

	// --- Overload editing methods ---

	addOverload() {
		const newOverload: ScrFunctionOverload = {
			calledOn: null,
			parameters: [],
			returns: { void: true }
		};
		this.function.overloads = [...this.function.overloads, newOverload];
	}

	removeOverload(overloadIndex: number) {
		if (this.function.overloads.length <= 1) return;
		this.function.overloads = this.function.overloads.filter((_, i) => i !== overloadIndex);
	}

	duplicateOverload(overloadIndex: number) {
		const source = this.function.overloads[overloadIndex];
		const duplicate: ScrFunctionOverload = JSON.parse(JSON.stringify(source));
		const newOverloads = [...this.function.overloads];
		newOverloads.splice(overloadIndex + 1, 0, duplicate);
		this.function.overloads = newOverloads;
	}
}
