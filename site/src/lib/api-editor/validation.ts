import type { ScrDataType, ScrFunction, ScrFunctionOverload } from '$lib/models/library';
import { ScrEntityTypes } from '$lib/models/library';

/**
 * Validates a function definition and returns a list of error messages.
 * 
 * Stricter rules apply if the function has the 'verified' flag.
 */
export function validateFunction(fn: ScrFunction): string[] {
	const errors: string[] = [];
	const isVerified = fn.flags.includes('verified');

	errors.push(...validateName(fn));
	errors.push(...validateFlags(fn));
	errors.push(...validateDescription(fn, isVerified));
	errors.push(...validateRemarks(fn, isVerified));

	fn.overloads.forEach((overload, index) => {
		const prefix = fn.overloads.length > 1 ? `Overload ${index + 1}: ` : '';
		errors.push(...validateOverload(overload, isVerified, prefix));
	});

	return errors;
}

function validateName(fn: ScrFunction): string[] {
	const errors: string[] = [];
	if (fn.name && fn.name[0] !== fn.name[0].toUpperCase()) {
		errors.push('Name: should be approx. PascalCase.');
	}
	return errors;
}

function validateFlags(fn: ScrFunction): string[] {
	const errors: string[] = [];
	if (fn.flags.includes('autogenerated') && fn.flags.includes('verified')) {
		errors.push('Flags: cannot be both autogenerated and verified.');
	}
	return errors;
}

function validateDescription(fn: ScrFunction, isVerified: boolean): string[] {
	const errors: string[] = [];
	if (!fn.description || fn.description === 'No description.') {
		errors.push('Description: missing or default.');
	} else if (isVerified && !isSentence(fn.description)) {
		errors.push('Description: should be a sentence.');
	}
	return errors;
}

function validateRemarks(fn: ScrFunction, isVerified: boolean): string[] {
	const errors: string[] = [];
	if (fn.remarks) {
		fn.remarks.forEach((remark, index) => {
			if (isVerified && remark && !isSentence(remark)) {
				errors.push(`Remark ${index + 1}: should be a sentence.`);
			}
		});
	}
	return errors;
}

function isSentence(str: string): boolean {
	if (!str) return false;
	return str[0] === str[0].toUpperCase() && str.endsWith('.');
}

function validateType(type: ScrDataType | null | undefined, label: string): string[] {
	const errors: string[] = [];
	if (!type) {
		return errors;
	}

	// Validate entity subtypes - if specified, must be a known type
	// Empty/null subtype means "any" which is valid
	if (type.dataType === 'entity') {
		const subType = type.subType ?? type.instanceType;
		if (subType && !ScrEntityTypes.includes(subType as typeof ScrEntityTypes[number])) {
			errors.push(`${label}: '${subType}' is not a valid entity type.`);
		}
	}

	return errors;
}

function validateOverload(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];

	errors.push(...validateCalledOn(overload, isVerified, prefix));
	errors.push(...validateParameters(overload, isVerified, prefix));
	errors.push(...validateReturns(overload, isVerified, prefix));

	return errors;
}

function validateCalledOn(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];
	if (overload.calledOn) {
		const label = `${prefix}Called on entity`;
		if (!overload.calledOn.name || overload.calledOn.name === 'unknown') {
			errors.push(`${label}: unknown name.`);
		}
		if (overload.calledOn.description) {
			if (isVerified && !isSentence(overload.calledOn.description)) {
				errors.push(`${label}: description should be a sentence.`);
			}
		} else if (isVerified) {
			errors.push(`${label}: description missing.`);
		}
		if (isVerified) {
			if (!overload.calledOn.type?.dataType) {
				errors.push(`${label}: type missing.`);
			}
		}
		errors.push(...validateType(overload.calledOn.type, label));
	}
	return errors;
}

function validateParameters(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];
	let foundOptional = false;
	let alreadyErrored = false;

	overload.parameters.forEach((param, pIndex) => {
		const pName = param.name || 'unknown';
		const pLabel = `${prefix}Parameter ${pIndex + 1}`;

		if (pName === 'unknown') {
			errors.push(`${pLabel}: unknown name.`);
		}

		if (param.mandatory === false) {
			foundOptional = true;
		} else if (param.mandatory === true && foundOptional && !alreadyErrored) {
			errors.push(`${prefix}Parameters: mandatory parameters cannot follow optional ones.`);
			alreadyErrored = true;
		}

		if (param.description) {
			if (isVerified && !isSentence(param.description)) {
				errors.push(`${pLabel}: description should be a sentence.`);
			}
		} else if (isVerified) {
			errors.push(`${pLabel}: description missing.`);
		}

		if (isVerified) {
			if (!param.type?.dataType) {
				errors.push(`${pLabel}: type missing.`);
			}
		}

		errors.push(...validateType(param.type, pLabel));
	});
	return errors;
}

function validateReturns(overload: ScrFunctionOverload, isVerified: boolean, prefix: string): string[] {
	const errors: string[] = [];
	const label = `${prefix}Return value`;
	if (overload.returns) {
		if (overload.returns.description) {
			if (isVerified && !isSentence(overload.returns.description)) {
				errors.push(`${label}: description should be a sentence.`);
			}
		}
		if (isVerified) {
			if (!overload.returns.void && !overload.returns.type?.dataType) {
				errors.push(`${label}: type missing.`);
			}
		}
		errors.push(...validateType(overload.returns.type, label));
	} else if (isVerified) {
		errors.push(`${label} section: missing.`);
	}
	return errors;
}
